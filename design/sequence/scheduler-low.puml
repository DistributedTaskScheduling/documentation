@startuml test

box "Server"
    participant ":Database" as db
    participant ":Scheduler" as s
    participant ":Dispatcher" as d
end box

s++
s -> db ++: get_runnable_jobs()
db --> s --: runnig_jobs: list[Job]

s -> db ++: get_available_wm()
db --> s --: available_wm: list[WorkMachine]

s -> s ++: sort_by_effective_priority(running_jobs)
note right of s 
    this method sorts all the job by the effective 
    priority and reterns a sorted list 
end note
s --> s --: running_jobs

s -> s ++: sort_wm_by_preemption_cost()
    loop wm in available_wm
        s -> s ++: calculate_preemption_cost()
        note right of s 
            we will need this later for jobs with priority 
            above preemption (returns a sorted list)
        end note
        s --> s --: preemption_cost: int
    end 
s --> s --: preemption_list: list[WorkMachine]

s -> s ++: sort_wm_by_blocking_cost()
    loop wm in available_wm
        s -> s ++: calculate_blocking_cost()
        note right of s 
            we will need this later for jobs with priority 
            above blocking (returns a sorted list)
        end note
        s --> s --: blocking_cost: int
    end 
s --> s --: blocking_list: list[WorkMachine]



loop    for j in running_jobs

    loop wm in available_wm
        s -> s ++: check_specs()
        s --> s --: is_checked: bool
        alt is_checked
            s -> s ++: match()
            note right of s
                match method will add the job and the work 
                machine to the list of jobs to be dispatched 
            end note
            s --> s --:
        end    
    end

    alt j.get_priority > preemption
        loop wm in  preemption_list
        s -> s ++: check_match(0)
        note right of s
            checks if we can run j on wm if yes then j and wm 
            will be added to the list of jobs to be dispatched
        end note
        s --> s --:
        end


    else j.get_priority > blocking 
        loop wm in  blocking_list
        s -> s ++: check_match(1)
        note right of s 
            sets a blocking flag for wm
        end note 
        s --> s --: 
        end

    end


    s -> d ++: dispatch(changed_jobs: list[Job], changed_wms: list[WorkMachine])
    note right of s 
        send all the changes to the Dispatcher
    end note
    d -> d ++: check_changes()
        note right of d 
            Dispatcher finds the changes made 
            and acts upon that information
        end note 
    d --> d --: messages: list[Message]
    d --> s --: messages
end

s --> db : message
note right of db 
    the messages contain the state of  
    the jobs sent to the Dispatcher
end note 

@enduml
